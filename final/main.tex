\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{template/lipics-v2021}

\usepackage{float}
\usepackage{adjustbox}

\title{AFP Project: Implementing an efficient version of Data.Map in Agda}
\author{Sebastiaan Koppen}{Utrecht University, Netherlands}{}{}{}
\author{Myrthe Streep}{Utrecht University, Netherlands}{}{}{}
\author{Daan van Westerlaak}{Utrecht University, Netherlands}{}{}{}

\authorrunning{M.D. Streep, S. Koppen, D. van Westerlaak}

\date{April 2025}

\bibliographystyle{acm}

\lstset{
  escapeinside={(*}{*)},
}

\begin{document}

\maketitle

\section*{Introduction}
Data.Map is a widely used Haskell module from the containers package. It provides an optimized implementation of a dictionary-like data structure (i.e. a mapping from keys to values), based on the concept of binary search trees of bounded balance. In our initial project proposal, we suggested that such a data structure would be a useful addition to Agda. Our reasoning was that a \textit{high-quality} package would be a useful addition to Agda, as it could provide other users with a reliable, fast implementation. While we still believe in the usefulness of this implementation, we have come to learn that our initial reasoning was based on incomplete knowledge of Agda. More specifically, we now understand that speed is not a focus point of Agda, partly because it does not have a run-time in the way most languages do. Fortunately, this does not mean that our implementation is useless. A correct-by-design implementation of Data.Map can function as a tool to prove properties over Data.Map and - by extension - as a tool for identifying vulnerabilities in the data structure.

The rest of this report is layed out as follows. We will first discuss our implementation of Data.Map, as well as the sized variant and sized-balanced variant we made. We then discuss what obstacles we encountered during the project as well as some noticable things we learned. Finally we will discuss some vulnerabilities we identified in the Haskell-implementation.


\section*{Agda}
\subsection*{Na\"ive implementation}
An initial implementation, based on its Haskell equivalent, can be found at \texttt{src/Map} directory. Tests and proofs corresponding to each module can be found at \texttt{src/Map/Test}. A second implementation, where the size of the map is incorporated in its type, can be found at \texttt{src/SizedMap}. Finally, an implementation incorporating both the size anf a proof of balance, can be found at \texttt{src/BalancedMap}.

When working with binary search trees, a compromise must be made between time it takes to find an element - which depends on how well-balanced the tree is - and the frequency with which the tree is rebalanced. What makes binary trees of bounded balance unique is that they carry a parameter that controls when a rebalancing is triggered. A first implementation of this can be found in the file \texttt{Map.Balance.agda}, where the constants \texttt{delta} and \texttt{ratio} are introduced. The usage of these constants corresponds to the description given by Stephen Adams \cite{adams1993functional} (although it must be pointed out that the creators of the Haskell implementation point out a small error in this paper). The \texttt{Map.Balance} module contains several functions that restore the balance of some (partially) tree. Some functions, such as \texttt{balanceL} and \texttt{balanceR}, assume that one of the sub-trees of the input is already balanced, allowing for faster rebalancing.

% We would be interested in varying these constants as part of our performance testing, as the optimal values found by the creators of Data.Map do not seem to coincide with those found by the authors of the corresponding paper.

\subsection*{Sized implementation}

\subsection*{Agda as proof assistant}
Agda was also used as proof assistant for the implemented functions, the implementations are inspired by the examples and equalities of the Hackage page of \href{https://hackage.haskell.org/package/containers-0.8/docs/Data-Map-Lazy.html}{Data.Map.Lazy}. 
Some functions are supposed to work on all instances of its record of Map.Map.agda, so to be able to formalize some proof we made an instance for it and proved that function for that instance. An example of this can be found in the function traverseWithKey of Map.Traversal with the test in Test.Traversal and the instance in Map.Map.
The proofs mostly use what was taught in the Agda lectures, but the there in $\in$ was changed to thereL and thereR to prove the branch of the element.
When some functions were proved, it became clear that there are missing cases that only arise when the function is not used properly. An example of this can be found in a part of the balanceL function in Listing \ref{balanceL}.

\begin{lstlisting}[label=balanceL,caption=balanceL assumes that the size of a node is 3 when the right branch is a tip.]
balanceL k v (node _ lk lv tip (node _ lrk lrv _ _)) tip = 
    node 3 lrk lrv (node 1 lk lv tip tip) (node 1 k v tip tip)
\end{lstlisting}

An example of a function that is proved formally is foldr which is partly shown in Listing \ref{foldrProof}. We did not expect this proof to be so hard as the function is so similar to the foldr function on lists, but the recursive calls to foldr made it harder (the elems function also uses foldr).

\begin{lstlisting}[label=foldrProof,caption=The following equality is proved foldr f z $\equiv$ foldr f z . elems]    
foldr(*$\equiv$*)foldrList-elems : {{Comparable K}} (*$\to$*) (f : A (*$\to$*) V (*$\to$*) V) 
  (*$\to$*) (z : V) (*$\to$*) (m : Map K A) (*$\to$*) foldr f z m (*$\equiv$*) foldrList f z (elems m)
foldr(*$\equiv$*)foldrList-elems f z tip = refl
foldr(*$\equiv$*)foldrList-elems f z (node x k v l r) (*$\equiv$*) 
  foldr f z (node x k v l r) 
      (*$\equiv\langle$*) ((foldr(*$\equiv$*)foldrList-elems f z r) under (f v)) 
      under ((*$\lambda$*) y (*$\to$*) foldr f y l) (*$\rangle$*)
  (foldr f (f v (foldrList f z (elems r))) l 
      (*$\equiv\langle$*) foldr(*$\equiv$*)foldrList-elems f (f v (foldrList f z (elems r))) l (*$\rangle$*)
  (foldrList f (f v (foldrList f z (elems r))) (elems l) 
      (*$\equiv\langle$*) sym (foldrList-split f z (elems l) (v :: elems r)) (*$\rangle$*)
  (foldrList f z (elems l ++ (v :: elems r)) 
      (*$\equiv\langle$*) (sym (elems(*$\equiv$*)elems  x k v l r)) under (foldrList f z) (*$\rangle$*)
  (foldrList f z (elems (node x k v l r)) (*$\blacksquare$*))))) 
\end{lstlisting}

\section*{Performance}

\bibliography{main}
\end{document}
